<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with jLaTeX2HTML 2002 (1.62) JA patch-1.4
patched version by:  Kenshi Muto, Debian Project.
LaTeX2HTML 2002 (1.62),
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Homework 1 Solutions</TITLE>
<META NAME="description" CONTENT="Homework 1 Solutions">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="keywords" CONTENT="Brian Howard,DePauw University,Computer Organization">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="jLaTeX2HTML v2002 JA patch-1.4">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="hw1sol.css">

</HEAD>

<BODY >

<H1 ALIGN="CENTER">Homework 1 Solutions</H1>

<P>

<UL>
<LI><SPAN  CLASS="textbf">Exercise 2.1.</SPAN> <I>The function <code>sum</code> in Program 2.12 is called for the first time by the main program.  From the second time on it is called by itself.</I>

<OL>
<LI><I>How many times is it called altogether?</I>

<P>
It is called once each with argument <code>n</code> being 3, 2, 1, and 0, for a total of four times.

<P>
</LI>
<LI><I>Draw a picture of the main program variables and the run-time stack just after the function is called for the third time.  You should have three stack frames.</I>

<P>
<DIV ALIGN="CENTER">
<BR>
<IMG
 WIDTH="450" HEIGHT="210" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="\begin{picture}(210,130)
\thicklines\put(160,90){\framebox (40,40){}}
\put(160,5...
...0}}
\put(100,105){\line(0,-1){80}}
\put(100,45){\vector(-1,0){60}}
\end{picture}">
<BR>
</DIV>

<P>
</LI>
<LI><I>Draw a picture of the main program variables and the run-time stack just before the return from the call of part (b).  You should have three stack frames, but with different contents from part (b).</I>

<P>
The only change is the return value in the top-most stack frame:
<DIV ALIGN="CENTER">
<BR>
<IMG
 WIDTH="450" HEIGHT="210" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="\begin{picture}(210,130)
\thicklines\multiput(160,10)(0,40){3}{\framebox (40,40)...
...0}}
\put(100,105){\line(0,-1){80}}
\put(100,45){\vector(-1,0){60}}
\end{picture}">
<BR>
</DIV>

<P>
</LI>
</OL>

<P>
</LI>
<LI><SPAN  CLASS="textbf">Exercise 2.5.</SPAN> <I>Draw the call tree as in Figure 2.15 for procedure <code>permute</code> of Program 2.15 for the following call statements from the main program:
</I>
<OL>
<LI><code>permute("wxyz ", 0, 3)</code>
</LI>
<LI><code>permute("wxyz ", 1, 3)</code>
</LI>
<LI><code>permute("wxyz ", 1, 2)</code>
</LI>
<LI><code>permute("wxyz ", 2, 2)</code>
</LI>
</OL><I>
How many times is the procedure called?  What is the maximum number of stack frames on the run-time stack during the execution?  In what order does the program make the calls and returns?</I>

<P>

<OL>
<LI>The call tree below shows that the procedure is called a total of 41 times.  There are a maximum of four stack frames (for calls to <code>permute</code>) on the run-time stack at any one time, as can be seen from the fact that the call tree is only four levels deep; that is, the stack only has to remember the sequence of parent nodes from the root to any particular call, since it finishes visiting one branch of the tree before moving on to the next (this is called a ``depth-first tree traversal'').  The order in which the calls are made can be read off of the call tree by tracing around the outer edge of the tree clockwise (similar to Figure 2.13).

<P>
<DIV ALIGN="CENTER">
 
<BR>
<IMG
 WIDTH="717" HEIGHT="439" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="\begin{picture}(300,240)
\put(0,120){\makebox(0,0){\tt permute(''wxyz '',0,3)}}
...
...,20){12}{\line(0,1){10}}
\multiput(250,5)(0,10){24}{\line(1,0){5}}
\end{picture}">
<BR>
</DIV>

<P>
</LI>
<LI>The call tree in this case is the first child subtree of the root in part (a), containing 10 nodes.  The maximum depth is three, so that is also the maximum number of stack frames.

<P>
</LI>
<LI>The call tree in this case has only three nodes:
<DIV ALIGN="CENTER">
 
<BR>
<IMG
 WIDTH="349" HEIGHT="34" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="\begin{picture}(100,20)
\put(0,10){\makebox(0,0){\tt permute(''wxyz '',1,2)}}
\p...
...\put(50,5){\line(0,1){10}}
\multiput(50,5)(0,10){2}{\line(1,0){5}}
\end{picture}">
<BR>
</DIV>
The depth is two, so there will be at most two stack frames on the run-time stack.

<P>
</LI>
<LI>The call tree in this case is the first child subtree of the root in part (c), containing only one node.  There is only one stack frame.
</LI>
</OL>

<P>
</LI>
<LI><SPAN  CLASS="textbf">Exercise 2.6.</SPAN> <I>For Exercise 5, draw the run-time stack just after the following function calls:</I>

<OL>
<LI><code>permute("xwyz ", 2, 3)</code>

<P>
<DIV ALIGN="CENTER">
<BR>
<IMG
 WIDTH="436" HEIGHT="353" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="\begin{picture}(210,190)
\thicklines\multiput(160,10)(0,60){3}{\framebox (40,60)...
...){2}{\line(0,-1){10}}
\multiput(100,65)(0,60){2}{\vector(1,0){60}}
\end{picture}">
<BR>
</DIV>

<P>
</LI>
<LI><code>permute("wyzx ", 3, 3)</code>

<P>
<DIV ALIGN="CENTER">
<BR>
<IMG
 WIDTH="436" HEIGHT="353" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="\begin{picture}(210,190)
\thicklines\multiput(160,10)(0,60){3}{\framebox (40,60)...
...){2}{\line(0,-1){10}}
\multiput(100,65)(0,60){2}{\vector(1,0){60}}
\end{picture}">
<BR>
</DIV>

<P>
</LI>
<LI><code>permute("wyxz ", 2, 2)</code>

<P>
<DIV ALIGN="CENTER">
<BR>
<IMG
 WIDTH="436" HEIGHT="242" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="\begin{picture}(210,130)
\thicklines\multiput(160,10)(0,60){2}{\framebox (40,60)...
...{80}}
\put(100,75){\line(0,-1){10}}
\put(100,65){\vector(1,0){60}}
\end{picture}">
<BR>
</DIV>

<P>
</LI>
<LI><code>permute("wxyz ", 2, 2)</code>

<P>
<DIV ALIGN="CENTER">
<BR>
<IMG
 WIDTH="436" HEIGHT="132" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.png"
 ALT="\begin{picture}(210,70)
\thicklines\put(160,10){\framebox (40,60){}}
\put(150,10...
...
\put(160,60){\makebox(40,10){?}}
\put(180,15){\vector(-1,0){140}}
\end{picture}">
<BR>
</DIV>

<P>
</LI>
</OL>

<P>
</LI>
<LI><SPAN  CLASS="textbf">Exercise 2.12.</SPAN> <I>Write a recursive procedure called <code>rotateLeft</code>, which should rotate the first <SPAN CLASS="MATH"><I>n</I></SPAN> numbers in an array of numbers to the left.  To rotate <SPAN CLASS="MATH"><I>n</I></SPAN> items left, rotate the first <SPAN CLASS="MATH"><I>n</I> - 1</SPAN> items left recursively, and then exchange items <SPAN CLASS="MATH"><I>n</I> - 1</SPAN> and <SPAN CLASS="MATH"><I>n</I></SPAN>.  For example, to rotate the five items
</I><!-- MATH
 \begin{displaymath}
\begin{array}{ccccc} 5.0 & -2.3 & 7.0 & 8.0 & 0.1 \end{array}
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<TABLE>
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER">5.0</TD>
<TD ALIGN="CENTER">-2.3</TD>
<TD ALIGN="CENTER">7.0</TD>
<TD ALIGN="CENTER">8.0</TD>
<TD ALIGN="CENTER">0.1</TD>
</TR>
</TABLE>
</DIV><P></P><I>
to the left, recursively rotate the first four items to the left:
</I><!-- MATH
 \begin{displaymath}
\begin{array}{ccccc} -2.3 & 7.0 & 8.0 & 5.0 & 0.1 \end{array}
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<TABLE>
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER">-2.3</TD>
<TD ALIGN="CENTER">7.0</TD>
<TD ALIGN="CENTER">8.0</TD>
<TD ALIGN="CENTER">5.0</TD>
<TD ALIGN="CENTER">0.1</TD>
</TR>
</TABLE>
</DIV><P></P><I>
and then exchange items four and five.
</I><!-- MATH
 \begin{displaymath}
\begin{array}{ccccc} -2.3 & 7.0 & 8.0 & 0.1 & 5.0 \end{array}
\end{displaymath}
 -->
<P></P>
<DIV ALIGN="CENTER" CLASS="mathdisplay">
<TABLE>
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER">-2.3</TD>
<TD ALIGN="CENTER">7.0</TD>
<TD ALIGN="CENTER">8.0</TD>
<TD ALIGN="CENTER">0.1</TD>
<TD ALIGN="CENTER">5.0</TD>
</TR>
</TABLE>
</DIV><P></P><I>
Do not use a loop.</I>

<P>
Here is one solution:
<PRE>
void rotateLeft(double a[], int n)
{
    // Do nothing if n &lt;= 1 -- base case
    if (n &gt; 1)
        // First rotate n-1 items, then exchange the last two
        rotateLeft(a, n - 1);
        
        double temp = a[n - 2];
        a[n - 2] = a[n - 1];
        a[n - 1] = temp;
    }
}
</PRE>

<P>
</LI>
<LI><SPAN  CLASS="textbf">Exercise 2.15.</SPAN> <I>Write a program to print all combinations of <SPAN CLASS="MATH"><I>n</I></SPAN> letters taken <SPAN CLASS="MATH"><I>r</I></SPAN> at a time.  As opposed to permutations, the order of the elements in combinations is irrelevant.  For example, the combinations of six letters taken four at a time are the possible sets of four letters from abcdef as follows:
</I>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3>
<TR><TD ALIGN="CENTER"><I>
abcd </I></TD>
<TD ALIGN="CENTER"><I> bcde </I></TD>
<TD ALIGN="CENTER"><I> cdef</I></TD>
</TR>
<TR><TD ALIGN="CENTER"><I> 
abce </I></TD>
<TD ALIGN="CENTER"><I> bcdf </I></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="CENTER"><I> 
abcf </I></TD>
<TD ALIGN="CENTER"><I> bcef </I></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="CENTER"><I> 
abde </I></TD>
<TD ALIGN="CENTER"><I> bdef </I></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="CENTER"><I> 
abdf </I></TD>
<TD></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="CENTER"><I> 
abef </I></TD>
<TD></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="CENTER"><I> 
acde </I></TD>
<TD></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="CENTER"><I> 
acdf </I></TD>
<TD></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="CENTER"><I> 
acef </I></TD>
<TD></TD>
<TD></TD>
</TR>
<TR><TD ALIGN="CENTER"><I> 
adef </I></TD>
<TD></TD>
<TD></TD>
</TR>
</TABLE></DIV><I>
The solution for selecting four letters from abcdef is to first output `a' followed by the solution for selecting three letters from bcdef.  Then output `b' followed by the solution for selecting three letters from cdef.  Then output `c' followed by the solution for selecting three letters from def.
</I>
<P>
<I>The following is the parameter list for a procedure to output the combinations:
</I><PRE>
void comb(char prefix[], int n, int r, char suffix[])
// Prints the prefix string followed by the combination
// of n characters taken r at a time from the suffix
// string.  Assumes suffix contains n characters.
</PRE><I>
To produce the previous list of combinations, the main program called
</I><PRE>
comb("", 6, 4, "abcdef")
</PRE><I>
The top-level recursive calls were
</I><PRE>
comb("a", 5, 3, "bcdef")
comb("b", 4, 3, "cdef")
comb("c", 3, 3, "def")
</PRE><I>
As in Program 2.15, you will need to make copies of <code>prefix</code> and <code>suffix</code> using <code>strcpy</code> from <code>string.h</code>.  Before each recursive call you will need to concatenate the first character from the suffix onto the last character of the prefix, and then strip the first character from the suffix.  You can use the procedure
</I><PRE>
strncat(char s[], const char c[], int n)
</PRE><I>
from <code>string.h</code> to perform the concatenation.  It concatenates <code>n</code> characters of string <code>c</code> to string <code>s</code>, so you can call it with an actual parameter of 1 for <code>n</code>.
</I>
<P>
<I>Draw the call tree for this data set.  How many times is your procedure called?  What is the maximum number of stack frames on the run-time stack?</I>

<P>
<PRE>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

void comb(char prefix[], int n, int r, char suffix[])
// Prints the prefix string followed by the combination of n characters taken
// r at a time from the suffix string.  Assumes suffix contains n characters.
{
    if (r == 0) {
        // No more characters are needed from suffix
        cout &lt;&lt; prefix &lt;&lt; endl;
    } else {
        // Allocate space for a copy of prefix, with one extra character
        // (plus a terminating NUL, for a C-style string)
        char *newPrefix = new char[strlen(prefix) + 2];
        
        // Choose one letter at a time from suffix to append to prefix,
        // making sure that at least r-1 characters may be chosen from the
        // rest of suffix
        for (int i = 0; i &lt;= n - r; i++) {
            strcpy(newPrefix, prefix);
            strncat(newPrefix, suffix + i, 1);
            comb(newPrefix, n - (i + 1), r - 1, suffix + (i + 1));
        }
        
        delete newPrefix;
    }
}

int main ()
{
    comb("", 6, 4, "abcdef");
}
</PRE>

<P>
Here is the call tree.  The procedure is called 35 times, with a maximum depth of five stack frames.
<DIV ALIGN="CENTER">
 
<BR>
<IMG
 WIDTH="881" HEIGHT="263" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="\begin{picture}(400,140)
\put(400,140){\makebox(0,0){\tt comb(''abcd'',2,0,''ef...
...,0){5}}
\put(350,75){\line(-1,0){5}}
\put(350,105){\line(-1,0){5}}
\end{picture}">
<BR>
</DIV>
</LI>
</UL>

<P>
<BR><HR>
<!--#include virtual='/~bhoward/common/foot.html' -->
</BODY>
</HTML>
